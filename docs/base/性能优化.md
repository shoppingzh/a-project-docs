# 性能优化

## 分析依赖包大小

在开始进行打包优化前，需要先分析当前依赖包的情况，一般来说，我们需要搞清楚以下几点：

| 问题 | 解决方案 |
| -- | -- |
| 打包产物中，某些js文件是否过大？ | 合理拆包 |
| 第三方依赖是否过多导致打包变慢？ | 依赖外置 |

### Vite实现方案

安装 `rollup-plugin-visualizer` 插件：

```ts
import visualizer from 'rollup-plugin-visualizer'

export default defineConig({
  plugins: [
    visualizer({
      sourcemap: true,
    }),
  ]
})
```

::: tip
如果在分析文件中看不到具体的文件内容，需要将 `build.sourcemap` 设置为 `true` 。
:::

插件设置完成后，再次打包，在项目根目录将生成 `stats.html` 文件，在浏览器中打开该文件：

![](./images/打包分析.png)

在我的这个项目里，第三方依赖被打成了两个 `js` 文件，每个文件都超过了 `1M` 。

很显然，打包产物过大，需要进行拆包处理。

并且，由于项目依赖的第三方库比较多，我们可以通过将依赖外置的方式来减少对第三方库的打包，从而加快构建速度。


## 拆包

我们先来拆包，拆包的原则是：

- 保证每个 `js` 产物不要过大；
- 如果是在HTTP1.1协议下，还要保证每个 `js` 产物不要过小，否则会打出太多的包，运行时将会阻塞导致应用启动过慢；
- `js` 产物的命名清晰。

### Vite实现方案

Vite的打包是基于rollup的（至少在Vite5及以前版本是这样的），因此，Vite没有提供拆包的配置，而是推荐用户直接覆盖rollup配置。

实现思路是修改 `build.rollupOptions.output.manualChunks` 配置，文档参考rollup的官方文档：[https://rollupjs.org/configuration-options/#output-manualchunks](https://rollupjs.org/configuration-options/#output-manualchunks) 。

这里给出一份我的实践思路，首先，提供一个配置文件 `config.ts` (位于项目目录 `build/config.ts` 中)，用户可以配置：

```ts

export type Chunks = Record<string, string[]>
export interface Config {
  /** 打包分包 */
  chunks: Chunks
}

export default {
  chunks: {
    'app': ['vue', 'vue-router', 'pinia'],
    'ui': ['element-plus'],
    'chart': ['echarts'],
    'utility': ['lodash', 'dayjs'],
  }
} as Config
```

::: tip
上述设置中，`vue` 、 `vue-router` 、 `pinia` 三个依赖包将被打入最终的 `app.js` 中。
:::

然后，在 `vite.config.ts` 中配置：

```ts
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        manualChunks(id) {
          for (const [name, packages] of Object.entries(config.chunks)) {
            const pass = packages.some(packageName => id.includes(`node_modules/${packageName}\/`))
            if (pass) return name
          }
          if (id.includes('node_modules')) return 'vendor'
        },
      },
    },
  },
})
```

::: tip
注意看 `manualChunks` 回调的最后一行，如果没有命中 `chunks` 中设置的规则，将会将 `node_modules` 中的依赖全部打进 `vendor.js` 中。
:::

接下来，执行打包命令验证一下拆包的结果：

![](./images/拆包结果.png)

![](./images/拆包分析.png)


## 依赖外置，CDN

我们在写下这行代码时：

```ts
import { merge } from 'lodash'
merge(a, b)
```

执行打包时，打包器会将 `lodash` 的代码打包到最终的产物中。

我们假设这个库的大小为10M，那打包时，光花在这一个包的处理时间都会特别长。

如果我们能让最终的代码变成这样：

```ts
const { merge } = window._
```

然后在入口html中加入这么一段 `<script>` 脚本：

```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
```

那打包时，我们就可以跳过 `lodash` 这个库的处理，从而节省一个库的处理时间。如果我们将所有耗时的依赖包全部外置，那理论上，打包就不需要时间。

::: tip
无论使用什么打包器（webpack、vite、rollup等），究其本质，其原理都是一样的。
:::

### Vite实现方案

在Vite中，我们可以使用 `vite-plugin-cdn-import` 插件快速实现这件事：

```ts
import cdn from 'vite-plugin-cdn-import'

export default defineConig({
  plugins: [
    cdn({
      name: 'lodash',
      var: '_',
      path: 'https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js',
    })
  ]
})
```

这个插件大致做了这些事情：
- 在rollup的 `external` 配置中，新增一条 `lodash` ，保证打包时，跳过它
- 在rollup的 `output.globals` 配置中，新增一条 `lodash: '_'`，保证打包产物中，引用模块时，通过全局方式进行引用
- 在生成最终的入口html文件时，加入 `<script>` 脚本，保证最终运行时，在全局可以读取到引用


## 去掉预处理器

TODO

## 合理设置legacy插件

TODO

