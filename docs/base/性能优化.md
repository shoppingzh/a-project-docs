# 性能优化

## 分析依赖包大小

TODO

## 依赖外置，CDN

我们在写下这行代码时：

```ts
import { merge } from 'lodash'
merge(a, b)
```

执行打包时，打包器会将 `lodash` 的代码打包到最终的产物中。

我们假设这个库的大小为10M，那打包时，光花在这一个包的处理时间都会特别长。

如果我们能让最终的代码变成这样：

```ts
const { merge } = window._
```

然后在入口html中加入这么一段 `<script>` 脚本：

```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
```

那打包时，我们就可以跳过 `lodash` 这个库的处理，从而节省一个库的处理时间。如果我们将所有耗时的依赖包全部外置，那理论上，打包就不需要时间。

::: tip
无论使用什么打包器（webpack、vite、rollup等），究其本质，其原理都是一样的。
:::

### Vite实现方案

在Vite中，我们可以使用 `vite-plugin-cdn-import` 插件快速实现这件事：

```ts
import cdn from 'vite-plugin-cdn-import'

export default defineConig({
  plugins: [
    cdn({
      name: 'lodash',
      var: '_',
      path: 'https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js',
    })
  ]
})
```

这个插件大致做了这些事情：
- 在rollup的 `external` 配置中，新增一条 `lodash` ，保证打包时，跳过它
- 在rollup的 `output.globals` 配置中，新增一条 `lodash: '_'`，保证打包产物中，引用模块时，通过全局方式进行引用
- 在生成最终的入口html文件时，加入 `<script>` 脚本，保证最终运行时，在全局可以读取到引用

## 拆包

TODO

## 去掉预处理器

TODO

